---
title:  "스레드의 종류 : 하드웨어 스레드, OS 스레드, 네이티브 스레드, 커널 스레드, 유저 스레드, 그린 스레드"
layout: single
categories: 
  - os

tags:
  - [CS, os, thread]

toc: true
toc_sticky: true

date: 2022-02-26
last_modified_at: 2022-02-26
---

*[`쉬운코드님`의 영상](https://www.youtube.com/watch?v=vorIqiLM7jc)의 내용을 기반으로 작성함.*
 
 스레드, 다양한 상황에서 다양한 종류의 스레드에 대한 용어들이 존재한다. 평소에 헷갈렸던 스레드 관련 용어들을 정리하자.  
 ++ 궁금했던 점 : 스레드는 스케줄링의 대상인가? 스케쥴러의 대상이라면, 혹은 대상이 아닌 스레드에 맵핑되는 용어를 정확히 알아보자.

 
# 들어가기 앞서

우리가 작성한 프로그램의 동작은 아래의 그림을 통해 간단하게 설명할 수 있다.

<img width="764" alt="image" src="https://user-images.githubusercontent.com/61482670/156016752-0ae01662-abe5-4320-a59c-b6b0e88fff37.png">


운영체제 위에서 우리 프로그램이 실행되며 우라의 프로세스는 운영체제를 통해서 하드웨어 자원( Memory, CPU, Devices)들을 활용하게 된다.

 이렇게 총 세 개의 레벨들로 구성되어 있고 이 글에서 다룰 스레드는 각 레벨과 관련된 스레들이다.




 # 하드웨어 스레드

CPU 레벨의 스레드로, 지금까지 배웠던 일반적인 스레드 개념과 전혀 다른 개념이다.

- CPU 프로세서는 연산작업을 위해 메모리에서 데이터를 읽어오거나 쓰는 작업을 한다. 이때, CPU 연산에 비해 코어에서 메모리 작업을 기다리는 시간이 상대적으로 너무 길다.
- 메모리 작업을 하는 동안 코어가 아무일도 하지 않고 기다리는 것은 코어의 자원낭비이다.
- 기다리는 동안 `다른 작업`을 실행하는 것은 어떨까??


<img width="887" alt="image" src="https://user-images.githubusercontent.com/61482670/156021172-72042149-de73-472d-a42d-255049e030a8.png">



메모리에 접근하는 공간공간마다 또다른 "작업" 을 실행한다. 그리되어 한개의 CPU 코어에서 두개의 작업의 흐름이 생겨나게 된다. 이 코어에서의 작업 흐름을 `하드웨어 스레드`라고 칭한다. 


## 인텔의 hyper-threading

인텔에서는 이 기술을 하이퍼 스레딩이라고 브랜딩했다. 물리적인 코어마다 하드웨어 스레드가 두 개씩 두는 기술이다. 

## 정리

- 하드웨어 스레드는 운영체제 관점에서 보았을 때 가상의 코어이다.
- 만약에 싱글 코어 cpu에서 하드웨어 스레드가 두 개라면 os는 이 **cpu를 듀얼 코어로 인식하고 듀얼 코어에 맞춰서 os레벨의 스레드들을 스케줄링**한다.
  
      - 하드웨어 스레드는 cpu상에서 각 코어마다 사용률을 극대화시키기 위해서 사용하는 cpu 레벨, 혹은 하드웨어 레벨의 스레드이다.


# OS 스레드

os 스레드는 지금까지 우리가 일반적으로 알고 있던 스레드의 개념이 바로 os 스레드이다.



**커널이란?**

    - 운영체제의 핵심으로 시스템의 전반을 관리/감독하는 역할을 하며 하드웨어와 관련된 작업을 직접 수행한다.

**os스레드란?**

    - os 커널레벨에서 생성되고 관리되는 스레드이다.
    - CPU에서 실제로 실행되는 작업의 단위, CPU 스케줄링의 단위


<br>

*os 스레드의 컨텍스트 스위칭은 커널이 개입해서 커널이 주도적으로 진행된다.*

- 이 말은 컨텍스트 스위칭이 일어날 때 마다 유저 모드에서 커널 모드로 모드 체인지가 발생하게 되고, CPU상에서 커널 코드가 일정기간 스위칭을 위해 작동하게 되고, 스위칭이 완료 된 후 다시 유저 모드로 돌아간다는 뜻으로 비용이 발생한다는 것을 의미한다. 즉 오버헤드(시간, cpu 리소스) 발생한다.

<br>

*사용자의 코드와 커널 코드 모두 os 스레드에서 실행된다.*

- 프로세스 주소공간에는 운영체제마다 다르지만 2:2 혹은 1:3 의 비율로 크기를 나누어 커널 영역이 들어가게 된다. 이 의미로, 사용자 프로세스가 실행 도중, interrupt 혹은 systemcall을 받았을 때 실행되는 os의 handler 코드는 같은 스레드 내에서 실행된다고 하는 것이다.


## OS 스레드의 다른 이름들

OS 스레드는 아래와 같이 불리기도 한다.

- 네이티브 (native) 스레드  
    (보통 '네이티브'라는 표현은 운영체제를 가리키는 말이다, 후반부에 알아보자)

- 커널 스레드  
  (맥락에 따라 다른 의미로 사용되기도 한다. 후반부에 살펴보자)
- 커널-레벨 스레드
- os-레벨 스레드

# User 스레드

**user 스레드란??**  

- 스레드 개념을 **프로그래밍 레벨에서 추상화**한것
- 유저 스레드는 user-level 스레드라고도 불리운다.

      💡 유저 스레드가 CPU에서 실행되려면, `OS 스레드와 반드시 연결`되어야 한다.
     
OS 스레드와의 연결?? 무슨 뜻인가 더 살펴보자


<img width="862" alt="image" src="https://user-images.githubusercontent.com/61482670/156026884-3b097e83-4bb6-4934-b5cf-3cc2294db1c4.png">

위 그림에서의 코드는 자바에서 스레드를 생성, 실행시키는 코드이다.

자바는 스레드 객체를 하나 만들고(`thread = new Thread()`), 이 스레드를 실행시킴으로써(`thread.start()`) 스레드를 동작시키게 된다.

<br>

*User thread? OS thread?*

자바 언어에서 위의 코드로 생성되는 Thread 객체가 앞서 살펴보았던 User thread 개념과 대응된다.

thread.start()가 실행되면 내부적으로 JNI라는 기술을 통해서 운영체제의 clone system call 을 호출하게 된다.(리눅스 기준) 이 시스템콜이 호출되면 OS는 OS-level의 스레드를 한 개 생성하게 된다.

즉, 코드로 생성한 user-level 스레드인 Thread 객체와 커널의 시스템 콜 함수에 의해 생성된 OS-level 스레드가 연결되게 되는 것이다.

## User 스레드와 OS 스레드의 연결 - Threading Model

그렇다면 자연스럽게 다음 주제는 User 스레드와 OS 스레드의 연결을 어떻게 하는 것인가? 일 것이다. 이에 관련한 세 가지 모델이 있다.

### One to One model



![Untitled](./../../assets/img/L4-Thread%209f2f6/Untitled%2015.png){: width="70%" height="70%"}{:.aligncenter}

앞서 살펴보았던 자바 코드의 예시와 동일하다.

오늘날의 자바는 user 스레드와 os 스레드가 일대일로 연결되는 모델이다.

- 유저 스레드와 os 스레드가 1:1로 맵핑이 되기 때문에 스레드의 관리를 유저 레벨이 아닌 운영체제에게 위임하게 된다.

- 이는 곧 유저 스레드가 커널 기능의 support를 받는다는 의미이며 **스케줄링의 대상에도 포함**된다는 뜻이다.

- 이는, 한 스레드가 block 이 되어도 전체 프로세스나, 다른 스레드들은 block하지 않고 동작할 수 있음을 의미한다.

- 또한, 멀티코어를 가진다면 멀티코어의 하드웨어 스레드들을  user 스레드와 연결된 os스레드들에 각각 맵핑하여 병렬적으로 처리할 수 있다는 뜻이다. 

단점
- 구현이 어렵고 복잡하다.
- 이 모델은 os 레벨의 스레드들과 1:1 맵핑 관계이기에 어떻게 실행되느냐에 따라 race condition이 발생할 수도 있어 동기화 이슈가 존재한다는 단점이 있다.

### Many to One model

![Untitled](./../../assets/img/L4-Thread%209f2f6/Untitled%2013.png){: width="70%" height="70%"}{:.aligncenter}


유저 레벨의 스레드가 여러개 있고, OS level의 스레드가 딱 하나만 존재하는 모델이다.

- 각 스레드들이 커널 입장에서는 하나의 프로세스로 인식된다.(스케쥴링의 대상 아님, 프로세스에 종속)
-  스레드 간 컨텍스트 스위치에 커널이 개입하지 않아 one-to-one모델에 비해 컨텍스트 스위치가 빠르다.
- OS 레벨에서 race condition이 일어날 가능성이 없다.(싱글 스레드이므로) 전체적으로도 race condition이 일어날 가능성이 적다.
- 상대적으로 가벼운 구현.

단점
- OS 레벨에서 race condition은 없지만, 유저 레벨에서 race condition의 가능성은 여전히 존재하므로 유저레벨에서 동기화 이슈를 잘 다뤄야한다.
- 하나의 스레드가 block된다면 전체 프로세스가 block상태가 되므로 다른 스레드들도 역시 block된다.( 이 문제를 해결하기 위해 non-block IO가 등장)
- 멀티코어를 활용할 수 없다.

### Many to Many Model


![Untitled](./../../assets/img/L4-Thread%209f2f6/Untitled%2016.png){: width="70%" height="70%"}{:.aligncenter}
One-to-One과 Many-to-Many 모델의 각각의 장점을 합쳐서 만든 모델이다. 솔라리스에서 시도한 모델이지만 오늘날에는 잘 안쓰인다. GO라는 언어에서 쓰인다고 한다.
구현이 복잡하다는 단점이 있다.


# 다른 관점, 맥락에서의 다양한 용어 의미들

기술 문서를 읽을 때 어떤 맥락, 관점에서 해당 용어를 쓰는지 주의하자.

**User Thread**: OS와는 독립적으로 유저 레벨에서 스케쥴링되는 스레드
 (Many to One 모델에서의 유저 스레드들을 한정에서 쓰이는 표현)


**Green Thread**: JAVA 초창기 버전은 Many to One 스레딩 모델을 사용해서 멀티스레딩을 구현했다고 한다. 이 떄 이 모델에서의 "유저 스레드"들을 `그린스레드`라고 불렀다. 

이 초창기 자바에서 쓰였던 그린 스레드라는 표현이 남아서 확장을 거듭해 오늘날까지 사용되게 되었다.

그래서 그린 스레드라는 표현은 결국 자바 초창기의 유저 스레드를 의미할 수도 혹은 그냥 general 하게 Many to One 모델의 User 스레드(OS와는 독립적으로 유저 레벨에서 스케쥴링 되는 스레드) 를 의미할 수도 있는 표현이 되었다.


**Kernel Thread**: OS 커널의 역할을 수행하는 스레드. 

운영체제는 시스템의 주요 동작을 관리 감독한다. 이때 운영체제의 주요 기능을 수행하는 커널 코드를 실제 실행하는 스레드들을 커널 스레드라고도 한다.

헷갈릴 수 있다. 정리해보면, 커널 스레드라는 용어는 1. 커널 레벨에서 실행되는 스레드를 의미하기도 (위의 OS 스레드), 혹은 2. 커널의 기능을 수행하는 커널 코드가 동작하는 스레드를 의미할 수도 있는 용어다.



# Reference

https://www.youtube.com/watch?v=vorIqiLM7jc
